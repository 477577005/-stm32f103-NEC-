# -stm32f103-NEC-

基于stm32f103芯片的NEC红外协议接收器
1、NEC协议：
	数据帧组成：
		引导信号（9ms低电平+4.5ms高电平）+四字节数据（设备地址+设备地址取反+命令码+命令码取反）
	数据‘1’‘0’表示：
		数据‘1’（0.56ms低电平+0.56ms高电平）；数据‘0’（0.56ms低电平+1.56ms高电平）
2、数据解析方式：
	循环等待，中断下降沿触发接收函数
3、环境
	编译软件：keil_MDK
	器件：stm32f103c8t6最小系统、HS0038B红外接收头

收获：
	1、学会了使用逻辑分析仪抓捕信号进行分析：
		使用过程中的遇到的问题，安装好驱动，点击开始捕获信号，立即就停止了，原因是我USB插在了USB拓展坞上，影响通信了。

	2、在寻找的示例代码中，发现了一个中断函数的执行规则：同一中断中，当芯片正在处理该中断函数时，如果当前没有执行完，
		即使再次触发中断，中断函数也不会从头执行，只会挂起一个中断请求，等待当前中断执行完毕才会去响应。

	3、在while中执行return，是退出函数，不仅仅是退出while循环。

	4、通过逻辑分析仪，发现数据校验时不对，针对第一个数据进行分析：原命令码0x45,串口打印的是十进制数69，正确，
		但是在value[2]=~value[3]时出现了错误，结果不相等，输出的命令码反码十进制186也与原命令码对应的上。
		问题就锁定在这个“value[2]=~value[3]”表达式,通过质询AI获得如下经验：
		（1）按位取反 (~)的隐式类型问题​
			unsigned char 的取反行为​：
			value[1] = 0xBA（十进制 186），~0xBA 的结果是 0x45（十进制 69）。
			但 ~ 操作默认会对操作数进行 ​整数提升​（提升为 int 类型），因此实际计算过程如下：
			~value[1] → ~(int)0xBA → 0xFFFFFF45（32位系统下）
			此时 value[0] == 0x45，而 ~value[1] == 0xFFFFFF45，两者不相等。
		​​(2) 修正方法：强制类型转换​
			需要将 ~ 的结果强制转回 unsigned char：
			if(value[0] == (unsigned char)~value[1])  // 显式转换
	5、红外信号的调整解调原理。
